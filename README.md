![run-tests](../../workflows/run-tests/badge.svg)

## 2024 Project 2

Εκφώνηση: https://k08.chatzi.org/projects/project2/


### Προσωπικά στοιχεία

__Όνομα__: Παντελής Κοντάρης

__Α.Μ.__: sdi2300079

### Ασκήσεις που παραδίδονται

Συμπληρώστε `[x]` στις ασκήσεις (και τυχόν bonus) που παραδίδετε.

- [x] Άσκηση 1
- [x] Άσκηση 2
- [x] Άσκηση 3
- [x] Άσκηση 4
- [x] Άσκηση 5
- [ ] Bonus 1
- [ ] Bonus 2

### Documentation

### Παρατήρηση: 

Όλες οι πολυπλοκότητες που αναφέρονται είναι χρονικές.

### Άσκηση 1

- Η set_from_vector διατρέχει 1-1 τα στοιχεία του vector, άρα σε χρόνο O(n) και το set_insert στη χειρότερη περίπτωση υλοποίησης κάνει n συγκρίσεις άρα πάλι σε χρόνο O(n). Τελικά Έχει πολυπλοκότητα O(n^2).
- H set_to_vector διατρέχει 1-1 τα στοιχεία του set, δηλαδή σε χρόνο O(n) και τα προσθέτει στο τέλος του vector, δηλαδή σε σχρόνο O(1). Τελικά έχει πολυπλοκότητα O(n).

### Άσκηση 2

- Η set_traverse διαπερνάει όλα τα στοιχεία του set δηλαδή O(n) και καλεί την f , που κάνει ορσιμένα βήματα ,δηλαδή O(1). Τελικά έχει πολυπλοκότητα O(n).
- ***Η set merge κάνει όσεις συγκρίσεις είναι το μικρότερο set, σηλαδή O(n1)=> O(n) και n1+n2 inserts δηλαδή O(n). Άρα έχει O(2n) => O(n) πολυπλοκόυητα
- Η set_find_k_smallest διατρέχει σειριακά το set. Επομένως έχει O(n) πολυπλοκότητα.

### Άσκηση 3

- Η set_to_vector χρησιμοποιεί μια βοηθητική συνάρτηση traverse_BST_insert_vector, η οποία αναδρομικά επισκέπτεται τα n στοιχεία του binary search tree, δηλαδή O(n) πολυπλοκότητα.
- Η set_traverse χρησιμοποιεί τη βοηθητική συνάρτηση traverse_BST_for_f ,η οποία έχει όμοια δομή με την traverse_BST_insert_vector και έχει πολυπλοκότητα O(n).

### Άσκηση 4

- Για την set_from_vector ακολύθησα 4 βήματα:
    - Διαχωρίζουμε το vector σε 2: ταξινομημένο και μη ταξινομημένο, με μία for loop που κάνει προσπέλαση σε όλα τα στοιχεία του vector επομένως έχει O(n) πολυπλοκότητα.
    - Ταξινομώ το unsorted vector με μία bubble sort, O((n2)^2) πολυπλοκότητα.
    - Κάνω merge τα δύο πλέον ταξινομημένα vectors. Η two_vector_merge κάνει όσεις συγκρίσεις είναι το μικρότερο vector, δηλαδή O(n1) και κάνει n1 + n2 vector_insert_last. Και οι δύο λειτουργίες(σύγριση και insert) έχουν O(1) πολυπλοκότητα άρα έχουμε O(n1+n2) πολυπλοκότητα.
    - Τέλος η create_tree_set δέχεται το merged vector, και προσθέτει το μεσαίο του στοιχείο στη δομή binary tree που έχω για το set. Αναδρομικά η διαδικασία γίνεται για το αριστερό και το δεξί μισό του vector κάνοντας σύνολο n insertions, δηλαδή πολυπλοκότητα O(n).
    - Συμπέρασμα: Αν το unsorted vector είναι μικρό σε μέγεθος η avergae case πολυπλοκότητα της συνάρτησης που υπερισχύει είναι O(n). Εναλλακτικά θα έχουμε O((n2)^2) πολυπλοκότητα.
- Η set_merge καλεί την two_vector_merge, η οποία όπως εξήγησα έχει O(n1+n2) πολυπλοκότητα. Στη συνέχεια καλεί την create_tree_set που όπως είπαμε πριν έχει O(n) πολυπλοκότητα δηλαδή στη συγκεριμένη περίπτωση O(n1+n2). Άρα έχουμε O(n1+n2) πολυπλοκότητα.

### Άσκηση 5

Τροποποίησα το struct set_node και πρόσθεσα ένα int children που μετρά πόσο παιδιά έχει ο κόμβος αυτός (μετράει και τον εαυτό του). Αυτό έγινε εφικτό με μία τροποποίηση στη node_create και node_insert του ADTSet.c
Στη συνέχεια έφτιαξα μια βοηθητική συνάρτηση recursive_finding η οποία ελέγχει αν το στοιχείο k (η θέση του σε σχέση από το μικρότερο στοιχείο του set) είναι μεγαλύτερο από τα παιδία του αριστερού υποδένδρου. Αν ναι μεταφέρουμε τη ρίζα στο δεξι παιδί της(πάμε δεξιά στο δένδρο) και αφαιρούμε από το k τα παιδία του αριστερού υποδένρου και συμπεριλαμβάνουμε και τη ρίζα.
Εναλλακτικά αν to κ είναι μικρότερο από τα παιδιά του αριστερού υποδένδρου πάμε αριστερά και δεν μεταβάλλουμε το κ. Όταν το κ ισούται με τα παιδία του αριστερού υποδένδρου έχουμε βρει τον κόμβο μας.

Αφού πάμε στο δεξί ή το αριστερό παιδί του δένδρου το πολύ όσο είναι το ;ycow toy δένδρου και το κάθε κατέβασμα έχει πολυπλοκότητα O(1), έχουμε πολυπλοκότητα O(h), όπου h το ύψος του δένρδου.

Συμπληρώστε εδώ __όσο documentation χρειάζεται__ ώστε οι βαθμολογητές να
κατανοήσουν πλήρως τις λύσεις σας και να τις βαθμολογήσουν ανάλογα. Αυτό θα
πρέπει να γίνει ανεξάρτητα με το αν ο κώδικάς σας είναι καλά σχολιασμένος,
πράγμα που συνιστάται.
